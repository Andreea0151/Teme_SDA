Nicu Andreea
311AB

												Tema 1: ATP Cup ğŸ†



	Implementarea programului este realizatÄƒ folosind fiÈ™ier header (Tema1.h) È™i sursÄƒ (Tema1.c). Metodele implementate sunt testate Ã®n fiÈ™ierul main.c.

âœ©CerinÈ›a 1
    Pentru prima cerinÈ›Äƒ, structura rezolvÄƒrii este astfel:
Fiecare nod din lista va contiune o variabilÄƒ de tip Country; Ã®n acest sens, fiecare echipa participantÄƒ a turneului va fi caracterizatÄƒ de numele È›Äƒrii respective, un scor global Ã®n care punctajul va fi obÈ›inut pe parcursul turneului, jucÄƒtori È™i numÄƒrul acestora. De asemenea, se cunosc date personale despre fiecare dintre aceÈ™tia: nume, prenume È™i scorul personal. Astfel:
-> jucÄƒtorii unei echipe vor fi reÈ›inuÈ›i Ã®ntr-un vector, funcÈ›ia "alocare_Player" alocÄƒ memorie pentru stocarea jucÄƒtorilor
-> datele acestora vor fi citite Ã®n funcÈ›ia "citire_Player" Ã®n ordinea Ã®n care aceÈ™tia se aflÄƒ Ã®n fiÈ™ierul de intrare, "date.Ã®n":
	- nume, prenume, pentru citirea cÄƒrora se va folosi un buffer;
	â• Ãn cazul Ã®n care un jucÄƒtor are 2 prenume, acestea sunt scrise cu cratimÄƒ "-" È™i reprezintÄƒ un singur È™ir de caractere. Pentru acest caz, am folosit un È™ir auxiliar (de tip char) prin intermediul cÄƒruia se verificÄƒ dacÄƒ primul caracter este cifra (caracter cifra) sau nu. Ãn situaÈ›ia afirmativÄƒ, Ã®nseamnÄƒ cÄƒ jucÄƒtorul nu are douÄƒ prenume, iar urmÄƒtoarea citire va fi a scorului. Altfel, funcÈ›ia "strcat" concateneaza cele 2 È™iruri È™i cratima dintre ele, reprezentÃ¢nd un singur È™ir de caractere.
-> "citire_Country" va citi astfel toate datele despre fiecare echipa participantÄƒ, dupÄƒ numele È›Äƒrii fiind apelata funcÈ›ia de citire a jucÄƒtorilor
-> È›Äƒrile participante sunt adÄƒugate Ã®ntr-o lista circularÄƒ, dublu Ã®nlÄƒnÈ›uitÄƒ, legÄƒtura dintre primul È™i ultimul nod fiind reprezentatÄƒ de santinelÄƒ

âœ©CerinÈ›a 2
    Pentru eliminarea È›Äƒrilor cu scor iniÈ›ial minim rezolvarea este abordatÄƒ astfel:
-> scorurile iniÈ›iale, reprezentate de media aritmeticÄƒ a scorurilor personale ale jucÄƒtorilor din lotul È›Äƒrii respective, au fost adÄƒugate Ã®ntr-un vector de medii: funcÈ›ia "scor_initial"
-> Ã®n structura listei am adÄƒugat un nou cÃ¢mp, "poziÈ›ie", ce va reÈ›ine poziÈ›ia unei È›Äƒri Ã®n vectorul de medii
-> funcÈ›ia "scor_minim" returneazÄƒ poziÈ›ia scorului minim din vector, iar atunci cÃ¢nd, Ã®n urmÄƒ parcurgerii, aceasta va coincide cu poziÈ›ia nodului, È›arÄƒ respectivÄƒ este eliminatÄƒ; de asemenea, odatÄƒ cu actualizarea listei, simultan, va fi actualizat È™i vectorul de medii prin funcÈ›ia "stergere_el_vector" (elimina scorul minim corespunzÄƒtor È›Äƒrii ce tocmai a fost eliminate), dar È™i cÃ¢mpul poziÈ›ie din structura, prin decrementare.
-> È™tergerea va fi apelata Ã®ntr-un while ("stergere_tara", respectiv "stergere_el_vector"), pÃ¢nÄƒ cÃ¢nd numÄƒrul È›Äƒrilor devine cea mai mare putere a lui 2 posibilÄƒ

âœ©CerinÈ›a 3
-> È›Äƒrile rÄƒmase Ã®n lista sunt adÄƒugate Ã®ntr-o stivÄƒ; operaÈ›ii folosite Ã®n program pentru aceastÄƒ structura de date:
    - push		-> adaugÄƒ element
    - isEmpty_stack  	-> verificÄƒ dacÄƒ existÄƒ echipe Ã®n stivÄƒ
    - pop        	-> elimina noduri din stivÄƒ
-> se scot succesiv cÃ¢te douÄƒ È›Äƒri din stivÄƒ, iar meciul dintre ele va fi adÄƒugat Ã®ntr-o coadÄƒ; operaÈ›ii - coadÄƒ:
    - createQueue	-> creare coadÄƒ
    - enQueue    	-> adÄƒugare element
    - isEmpty_queue    	-> verificÄƒ existenÈ›a nodurilor
    - deQueue    	-> scoaterea unui meci din coadÄƒ
-> funcÈ›ia "etapÄƒ" scoate È›Äƒri din stivÄƒ È™i adaugÄƒ meciuri Ã®n coadÄƒ, pÃ¢nÄƒ cÃ¢nd nu mai existÄƒ È›Äƒri
-> "meci", constÄƒ Ã®n confruntarea fiecÄƒrui jucÄƒtor din prima echipa cu toÈ›i ceilalÈ›i jucÄƒtori din echipa adversÄƒ, iar Ã®n urmÄƒ confruntÄƒrii este reÈ›inut scorul prin apelarea funcÈ›iei "punctaj"
-> Ã®n continuare, este verificat punctajul, iar È›arÄƒ cÃ¢È™tigÄƒtoare este adÄƒugatÄƒ Ã®ntr-o nouÄƒ stivÄƒ, WINNER ("push_WINNER")
-> funcÈ›ia "verificare" reÈ›ine scorul global al fiecÄƒrei echipe È™i returneazÄƒ È›arÄƒ cÃ¢È™tigÄƒtoare
-> funcÈ›ia "Stack_size" va returna numÄƒrul de elemente existente Ã®n stivÄƒ WINNER; astfel vor fi repetate procedeele descrise pÃ¢nÄƒ cÃ¢nd Ã®n WINNER va rÄƒmÃ¢ne o singurÄƒ echipa, cea cÃ¢È™tigÄƒtoare (atunci cÃ¢nd Stack_size == 1)

âœ©CerinÈ›a 4
-> jucÄƒtorii ultimelor patru È›Äƒri rÄƒmase Ã®n stiva WINNER vor fi adÄƒugaÈ›i Ã®ntr-un BST - arbore binar de cÄƒutare: Ã®n while-ul din cerinÈ›a anterioarÄƒ se declara o stivÄƒ auxiliarÄƒ, Aux, Ã®n care sunt adÄƒugaÈ›i jucÄƒtorii ultimelor 4 È›Äƒri cÃ¢È™tigÄƒtoare (atunci cÃ¢nd (Stack_size(WINNER) == 4) ); Ã®n acest fel, dupÄƒ ieÈ™irea din ciclul repetitiv, scorurile jucÄƒtorilor vor fi actualizate
-> funcÈ›ia "rÄƒdÄƒcina" creeazÄƒ rÄƒdÄƒcina arborelui, iar "Ã®nserare" adaugÄƒ jucÄƒtorii Ã®n continuare astfel:
    - dacÄƒ noul jucÄƒtor are scorul mai mic decÃ¢t al celui deja existent, acesta va fi inserat Ã®n stÃ¢nga celui cu care a fost comparat
    - altfel, va fi inserat Ã®n dreapta acestuia
    â• dacÄƒ scorurile celor doi jucÄƒtori sunt egale, atunci adÄƒugarea Ã®n arbore se va face cu ajutorul funcÈ›iei "strcmp" astfel:
        - va fi adÄƒugat jucÄƒtorul al cÄƒrui nume este primul dpdv alfabetic
        â• dacÄƒ Ã®nsÄƒ numele de familie sunt aceleaÈ™i, atunci:
            - se adaugÄƒ Ã®n arbore jucÄƒtorul al cÄƒrui prenume este primul dpdv alfabetic

âœ©CerinÈ›a 5
-> Ã®n fiÈ™ierul cerinÈ›e.Ã®n se gÄƒsesc numele È™i prenumele a 2 jucÄƒtori: se alocÄƒ memorie "alocare_memorie", iar datele celor doi sunt citite Ã®n funcÈ›ia "citire_cerinta5"
-> se numÄƒrara jucÄƒtorii din BST care care au scorul personal inclus Ã®ntre cele douÄƒ scoruri personale ale celor doi, aceÈ™tia nefiind incluÈ™i; Ã®n acest sens, funcÈ›ia de tip int, "numarare_jucatori", va primi cÄƒ parametru un nod de tip Arbore È™i douÄƒ numere, x È™i y, Ã®ntre care se va verificÄƒ scorul, urmÃ¢nd cÄƒ funcÈ›ia sÄƒ returneze numÄƒrul respectiv Ã®n cazul Ã®ndeplinirii condiÈ›iei (scorul âˆˆ (x ; y) ) .
    â• dacÄƒ un jucÄƒtor din cei doi primiÈ›i cÄƒ input nu se gÄƒseÈ™te Ã®n BST, se va afiÈ™a un mesaj corespunzÄƒtor; astfel, funcÈ›ia "cÄƒutare", printr-o implementare recursivÄƒ, returneazÄƒ 1 atunci cÃ¢nd este gÄƒsit numele jucÄƒtorului, altfel cÄƒutarea se continuÄƒ Ã®n subarborele stÃ¢ng, respectiv drept

	Functiile implementate sunt testate in main.c, prin apelarea acestora, introduse fiind de "printf-uri" corespunzatoare. Totodata, in fisierul "cerinte.in" exista valori (0, 1), fiecare cifrÄƒ fiind corespunzatoare fiecÄƒrei cerinÈ›e, iar valoarea ei hotÄƒrÄƒÈ™te dacÄƒ fiÈ™ierul de iesire rezultate.out va conÈ›ine afisarea cerinÈ›ei respective. In acest sens, am creat un vector v, in care au fost introduse valorile din fisier. Atunci cand valoarea din vector este diferita de 0 (v[i]), se va realiza cerinta corespunzatoare.
Structurile de date folosite, lista, stive, cozi È™i arbore binar de cÄƒutare, au fost declarate in "Tema1.h", alaturi de funtiile implementate in "Tema1.c". ğŸ’›

